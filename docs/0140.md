# Java 中的线程调度器

> 原文：<https://www.javatpoint.com/thread-scheduler-in-java>

决定运行或执行哪个线程以及等待哪个线程的 Java 组件在 Java 中被称为**线程调度器**。在 Java 中，线程只有在处于可运行状态时才会被线程调度器选择。但是，如果有多个线程处于可运行状态，则由线程调度器选择其中一个线程并忽略其他线程。有一些标准决定哪个线程将首先执行。调度线程有两个因素，即**优先级**和**到达时间**。

**优先级:**每个线程的优先级介于 1 到 10 之间。如果一个线程具有更高的优先级，这意味着该线程有更好的机会被线程调度器获取。

**到达时间:**假设两个优先级相同的线程进入可运行状态，那么优先级不能作为从这两个线程中挑选线程的因素。在这种情况下，线程调度器会考虑线程的**到达时间**。最先到达的线程比其他线程优先。

## 线程调度算法

基于上述因素，调度算法之后是一个 Java 线程调度器。

### 先到先得时间安排:

在这个调度算法中，调度器挑选在可运行队列中最先到达的线程。请遵守下表:

| 线 | 运到时间 |
| T1 级（一种通讯线路的名称） | Zero |
| t2 | one |
| t3 | Two |
| t4 | three |

在上表中，我们可以看到 Thread t1 先到达，然后是 Thread t2，然后是 t3，最后是 t4，处理线程的顺序是根据线程到达的时间。

![Thread Scheduler in Java](../img/5382ae58889704ac9c65df51ee787b48.png)

因此，首先处理线程 t1，最后处理线程 t4。

### 时间分片调度:

通常，先到先服务算法是非抢占式的，这是不好的，因为它可能会导致无限阻塞(也称为饥饿)。为了避免这种情况，会给线程提供一些时间片，这样一段时间后，正在运行的线程就不得不放弃 CPU。因此，其他等待线程也有时间运行它们的作业。

![Thread Scheduler in Java](../img/bc451a9734c3f082ef2145a6ae7c6787.png)

在上图中，每个线程都有一个 2 秒的时间片。因此，2 秒钟后，第一个线程离开中央处理器，然后中央处理器被线程 2 捕获。其他线程也重复同样的过程。

### 抢先优先调度:

调度算法的名称表示该算法与线程的优先级相关。

![Thread Scheduler in Java](../img/1f0803e0fd210759faf6574e5fdacaeb.png)

假设有多个线程处于可运行状态。线程调度器选择优先级最高的线程。由于该算法也是抢先的，因此，时间片也被提供给线程以避免饥饿。因此，一段时间后，即使最高优先级的线程没有完成它的工作，它也必须释放 CPU，因为抢占。

## Java 线程调度器的工作

![Thread Scheduler in Java](../img/43d5b684f15de683ad4115bfb7aa7814.png)

让我们了解一下 Java 线程调度器的工作原理。假设有五个线程，它们有不同的到达时间和不同的优先级。现在，线程调度器负责决定哪个线程将首先获得 CPU。

线程调度器选择优先级最高的线程，线程开始执行作业。如果一个线程已经处于可运行状态，而另一个线程(具有较高优先级)到达可运行状态，则当前线程被处理器抢先，到达的具有较高优先级的线程获得 CPU 时间。

当两个线程(线程 2 和线程 3)具有相同的优先级和到达时间时，调度将基于 FCFS 算法来决定。因此，先到达的线程有机会先执行。

* * *